스프링 기초 프로젝트2 & 스프링 시큐리티
----------
>기초 프로젝트에서 스프링 시큐리티와 JWT를 활용한 인증 인가, 게시글에 CRUD 댓글 추가하기

<br>


조건
1. 회원 가입 API
    - 닉네임, 비밀번호, 비밀번호 확인을 request에서 전달받기
    - 닉네임은 `최소 3자 이상, 알파벳 대소문자(a~z, A~Z), 숫자(0~9)`로 구성하기
    - 비밀번호는 `최소 4자 이상이며, 닉네임과 같은 값이 포함된 경우 회원가입에 실패`로 만들기
    - 비밀번호 확인은 비밀번호와 정확하게 일치하기
    - 데이터베이스에 존재하는 닉네임을 입력한 채 회원가입 버튼을 누른 경우 "중복된 닉네임입니다." 라는 에러메세지를 response에 포함하기

2. 로그인 API
    - 닉네임, 비밀번호를 request에서 전달받기
    - 로그인 버튼을 누른 경우 닉네임과 비밀번호가 데이터베이스에 등록됐는지 확인한 뒤, 하나라도 맞지 않는 정보가 있다면 "닉네임 또는 패스워드를 확인해주세요"라는 에러 메세지를 response에 포함하기

3. 로그인 검사
    - `아래 API를 제외하고` 모두 로그인 토큰을 전달한 경우만 정상 response를 전달받을 수 있도록 하기
        - 회원가입 API
        - 로그인 API
        - 게시글 목록 조회 API
        - 게시글 조회 API
        - 댓글 목록 조회 API
    - 로그인 토큰을 전달하지 않은 채로 로그인이 필요한 API를 호출한 경우 "로그인이 필요합니다." 라는 에러 메세지를 response에 포함하기
    - 로그인 토큰을 전달한 채로 로그인 API 또는 회원가입 API를 호출한 경우 "이미 로그인이 되어있습니다."라는 에러 메세지를 response에 포함하기

4.  댓글 목록 조회 API
    - 로그인 토큰을 전달하지 않아도 댓글 목록 조회가 가능하도록 하기
    - 조회하는 게시글에 작성된 모든 댓글을 목록 형식으로 response에 포함하기
    - 제일 최근 작성된 댓글을 맨 위에 정렬하기

5. 댓글 작성 API
    - 로그인 토큰을 전달했을 때에만 댓글 작성이 가능하도록 하기
    - 로그인 토큰을 전달하지 않은 채로 댓글 작성란을 누르면 "로그인이 필요한 기능입니다." 라는 에러 메세지를 response에 포함하기
    - 댓글 내용란을 비워둔 채 API를 호출하면 "댓글 내용을 입력해주세요" 라는 에러 메세지를 response에 포함하기

6. 댓글 수정 API
    - 로그인 토큰에 해당하는 사용자가 작성한 댓글만 수정 가능하도록 하기
    - API를 호출한 경우 기존 댓글의 내용을 새로 입력한 댓글 내용으로 바꾸기

7. 댓글 삭제 API
    - 로그인 토큰에 해당하는 사용자가 작성한 댓글만 삭제 가능하도록 하기

8. 회원가입 테스트 코드 작성
    - 회원가입시 구현한 아래 조건을 검사하는 테스트 코드를 작성하기
        - 닉네임은 `최소 3자 이상, 알파벳 대소문자(a~z, A~Z), 숫자(0~9)`로 이루어져 있어야 합니다.
        - 비밀번호는 `최소 4자 이상이며, 닉네임과 같은 값이 포함된 경우 회원가입에 실패`합니다.
        - 비밀번호 확인은 비밀번호와 정확하게 일치해야 합니다.
        - 데이터베이스에 존재하는 닉네임을 입력한 채 회원가입 버튼을 누른 경우 "중복된 닉네임입니다." 라는 에러 메세지를 response에 포함하기
    - 테스트 코드 실행 시 실제로는 데이터베이스에 연결되지 않도록 하기
    - 각 조건 별로 2개 이상의 테스트 케이스가 존재하도록 하기

<br>
DB 테이블 & API 목록

![image](https://user-images.githubusercontent.com/59018674/171380265-a9a48c5a-97cd-41b2-9f9a-ac898f205cb4.png)

<br>
트러블 슈팅

1.Notice와 Comment는 일대다, 다대일 관계를 가진다.

그렇기에 @ManyToOne, @OneToMany 어노테이션을 활용해 관계를 지어 주었다.

하지만 여기서 문제가 발생했다.
실행 후 댓글을 달 때
IllegalStateException이 발생한것.

오류 코드를 보니 에러가 상당히 길다... 뭔가 재귀 형식이 발생한건가?

내가 이렇게 요청을 많이 보내진 않았는데 문제를 확인해 보니

comment 작성 - notice 발동 - comment 발동- notice 발동.... 이런식으로 무한 반복이 되다가 stackoverflow가 발생했다.

해결 방안으로는 @JsonManagedReference와 @JsonBackReference를 각각 달아주어 무한 반복을 방지했다.

<br>
2.만약 하나의 글에 같은사람의 댓글이 두개가 있을 경우 처리가 되지 않았다.

내가 최초에 설계했던 구조는 comment entity의 id값을 담아놓는 p태그를 display none 처리를 하고 해당 클래스의 값을 불러오는 형태였다

하지만 같은사람의 댓글이 여러개일 경우 클래스가 중복이 가능하기에 값이 겹쳐져서 날라왔다.

그래서 반복문을 돌 때 p태그에 반복하는 i의 값을 id로 담아주고,
수정하기 버튼을 누를때마다 변수에 현재 for문의 i값을 담고 그 값으로 호출했다.,

프론트단의 트러블이었지만 오랜만에 아이디어를 떠올리기 위해 생각을 해서 써봤다.

<br>

질문 답변

<br>
사이트 주소
아니 왜 배포가 안돼 ㅁㄴㅇㄻㄴㅇㅀㄴㅇㅀ

webSecurity가 Bean을 생성하지 몬하자너~~~~
근데 로컬에선 잘 되자너~~~~


